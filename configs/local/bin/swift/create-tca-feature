#!/bin/bash
#
# create-tca-feature - Generate a TCA (The Composable Architecture) Feature
#
# DESCRIPTION:
#   Creates a complete TCA feature with Store and View files following best practices.
#   Automatically detects iOS deployment target and generates appropriate code
#   (WithPerceptionTracking for iOS < 17, no wrapper for iOS 17+).
#
# USAGE:
#   create-tca-feature <feature_name> [target_path]
#
# ARGUMENTS:
#   feature_name    Name of the feature in PascalCase (e.g., "TodoDetail")
#                   If ends with "Feature", it's removed for Store/View names
#   target_path     Target directory (optional, defaults to "Features/Sources")
#
# EXAMPLES:
#   create-tca-feature TodoDetail
#   create-tca-feature TodoDetailFeature
#   create-tca-feature UserProfile ~/Projects/MyApp/Features/Sources
#
# FEATURES:
#   - Auto-detects iOS version from Package.swift
#   - Generates @Reducer with @ObservableState
#   - Creates SwiftUI view with proper perception tracking
#   - Auto-updates Package.swift with new feature target
#   - Handles "Feature" suffix normalization
#
# AUTHOR:
#   Generated for TCA development workflow
#

set -e  # Exit on error

# Cleanup temporary files on exit
# This trap ensures .swift.tmp files created by sed are removed even on error
cleanup() {
    # Clean up any .tmp files created by sed in current directory and subdirectories
    find "$(pwd)" -name "*.swift.tmp" -type f -delete 2>/dev/null || true
}
trap cleanup EXIT ERR INT TERM

# ANSI color codes for terminal output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'  # No Color (reset)

# Utility functions for colored console output
print_error() { echo -e "${RED}âŒ $1${NC}"; }      # Print error message in red
print_success() { echo -e "${GREEN}âœ… $1${NC}"; }  # Print success message in green
print_info() { echo -e "${YELLOW}â„¹ï¸  $1${NC}"; }   # Print info message in yellow
print_warning() { echo -e "${YELLOW}âš ï¸  $1${NC}"; } # Print warning message in yellow

show_usage() {
    cat << EOF
Usage: create-tca-feature <feature_name> [target_path]

Creates a TCA feature with Store and View files following best practices.

Arguments:
    feature_name    Name of the feature (required, e.g., "TodoDetail" or "TodoDetailFeature")
    target_path     Target directory (optional, defaults to "Features/Sources")

Examples:
    create-tca-feature TodoDetail
    create-tca-feature TodoDetailFeature
    create-tca-feature UserProfile Features/Sources
    create-tca-feature Settings Apps/Sources

Notes:
    - If feature_name ends with "Feature", it will be removed for Store/View names
    - Example: "TodoDetailFeature" creates "TodoDetailStore" and "TodoDetailView"
    - Directory will use the original feature_name as provided
    - Existing files will be overwritten with default template

EOF
    exit 1
}

# Check for help first
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
    show_usage
fi

if [ $# -lt 1 ]; then
    show_usage
fi

FEATURE_NAME="$1"
TARGET_PATH="${2:-Features/Sources}"  # Default to Features/Sources if not specified

# Safely expand tilde (~) to home directory
# This avoids security issues with eval while supporting ~/path syntax
TARGET_PATH="${TARGET_PATH/#\~/$HOME}"

# Validate feature name format (PascalCase required)
if ! [[ "$FEATURE_NAME" =~ ^[A-Z][A-Za-z0-9]*$ ]]; then
    print_error "Invalid feature name. Must start with uppercase letter (PascalCase)."
    exit 1
fi

# Normalize feature name by removing "Feature" suffix for struct names
# Examples:
#   "TodoDetailFeature" -> "TodoDetail" (for structs)
#   "TodoDetail" -> "TodoDetail" (unchanged)
# Directory always uses the original FEATURE_NAME
NORMALIZED_NAME="$FEATURE_NAME"
if [[ "$FEATURE_NAME" =~ Feature$ ]]; then
    NORMALIZED_NAME="${FEATURE_NAME%Feature}"
    print_info "Feature suffix detected. Using '$NORMALIZED_NAME' for Store/View names"
fi

# Determine feature directory
FEATURE_DIR="$TARGET_PATH/$FEATURE_NAME"

# Check if target path exists - if not, provide helpful TCA structure info
if [ ! -d "$TARGET_PATH" ]; then
    print_error "Target path does not exist: $TARGET_PATH"
    echo ""
    echo "This script requires a TCA project structure."
    echo ""
    echo "Current directory: $(pwd)"
    echo ""
    echo "Expected structure:"
    echo "  your-project/"
    echo "  â”œâ”€â”€ Features/"
    echo "  â”‚   â”œâ”€â”€ Package.swift"
    echo "  â”‚   â””â”€â”€ Sources/"
    echo "  â”‚       â””â”€â”€ (features go here)"
    echo ""
    if [ ! -d "Features" ]; then
        echo "  âœ— Features/ directory not found"
    else
        echo "  âœ“ Features/ directory exists"
        if [ ! -d "Features/Sources" ]; then
            echo "  âœ— Features/Sources/ directory not found"
        fi
    fi
    echo ""
    echo "To create a new TCA project, run:"
    echo "  create-tca-project <ProjectName>"
    echo ""
    exit 1
fi

# Validate TCA project structure
#
# Checks if the target directory is part of a valid TCA project
# Searches for Package.swift in common locations and validates TCA dependency
#
# Arguments:
#   $1 - Target directory path
#
# Returns:
#   0 if valid TCA project, 1 otherwise
validate_tca_structure() {
    local target="$1"
    local is_valid=false
    local package_location=""

    # Check for Package.swift in common locations relative to target
    if [ -f "$target/../Package.swift" ]; then
        package_location="$target/../Package.swift"
        is_valid=true
    elif [ -f "Features/Package.swift" ]; then
        package_location="Features/Package.swift"
        # Verify target path is under Features
        if [[ "$target" == Features/* ]] || [[ "$target" == ./Features/* ]]; then
            is_valid=true
        fi
    elif [ -f "Package.swift" ]; then
        package_location="Package.swift"
        is_valid=true
    fi

    if [ "$is_valid" = false ]; then
        print_error "Invalid TCA project structure detected"
        echo ""
        echo "This script requires a TCA project structure with:"
        echo "  âœ— A Package.swift file (not found)"
        echo "  âœ— A Features/Sources directory structure"
        echo ""
        echo "Current directory structure:"
        if [ -d "Features" ]; then
            echo "  âœ“ Features/ directory exists"
            if [ -d "Features/Sources" ]; then
                echo "  âœ“ Features/Sources/ directory exists"
            else
                echo "  âœ— Features/Sources/ directory not found"
            fi
            if [ -f "Features/Package.swift" ]; then
                echo "  âœ“ Features/Package.swift exists"
            else
                echo "  âœ— Features/Package.swift not found"
            fi
        else
            echo "  âœ— Features/ directory not found"
        fi
        echo ""
        echo "To create a new TCA project, run:"
        echo "  create-tca-project <ProjectName>"
        echo ""
        echo "Or ensure you're in a valid TCA project directory."
        return 1
    fi

    # Verify Package.swift contains TCA dependencies
    if [ -n "$package_location" ]; then
        if ! grep -q "swift-composable-architecture" "$package_location" 2>/dev/null; then
            print_error "Package.swift does not contain TCA dependency"
            echo ""
            echo "Found Package.swift at: $package_location"
            echo "But it doesn't contain 'swift-composable-architecture' dependency."
            echo ""
            echo "Please add TCA to your Package.swift dependencies:"
            echo '  .package(url: "https://github.com/pointfreeco/swift-composable-architecture.git", branch: "main")'
            echo ""
            return 1
        fi
    fi

    return 0
}

# Validate structure before proceeding
if ! validate_tca_structure "$TARGET_PATH"; then
    exit 1
fi

print_success "Valid TCA project structure detected"

# Check if feature already exists
OVERWRITE=false
if [ -d "$FEATURE_DIR" ]; then
    OVERWRITE=true
    print_warning "Feature directory already exists: $FEATURE_DIR"
    print_warning "Existing Store and View files will be OVERWRITTEN with default template"
fi

# Detect iOS deployment target from Package.swift
# This determines whether to use WithPerceptionTracking wrapper in views
# iOS 17+ uses Observation framework (no wrapper needed)
# iOS < 17 requires WithPerceptionTracking for state observation
IOS_VERSION="17.0"
USE_PERCEPTION_TRACKING=false

# Find Package.swift in common locations
if [ -f "$TARGET_PATH/../Package.swift" ]; then
    PACKAGE_FILE="$TARGET_PATH/../Package.swift"
elif [ -f "Features/Package.swift" ]; then
    PACKAGE_FILE="Features/Package.swift"
elif [ -f "Package.swift" ]; then
    PACKAGE_FILE="Package.swift"
else
    PACKAGE_FILE=""
fi

# Parse Package.swift to detect iOS deployment target
if [ -n "$PACKAGE_FILE" ]; then
    # Extract iOS version from platform declaration
    if grep -q "\.iOS(\.v16)" "$PACKAGE_FILE" 2>/dev/null; then
        IOS_VERSION="16.0"
        USE_PERCEPTION_TRACKING=true
        print_info "Detected iOS 16.0 deployment target - will use WithPerceptionTracking"
    elif grep -q "\.iOS(\.v15)" "$PACKAGE_FILE" 2>/dev/null; then
        IOS_VERSION="15.0"
        USE_PERCEPTION_TRACKING=true
        print_info "Detected iOS 15.0 deployment target - will use WithPerceptionTracking"
    elif grep -q "\.iOS(\.v14)" "$PACKAGE_FILE" 2>/dev/null; then
        IOS_VERSION="14.0"
        USE_PERCEPTION_TRACKING=true
        print_info "Detected iOS 14.0 deployment target - will use WithPerceptionTracking"
    else
        print_info "Detected iOS 17.0+ deployment target - no WithPerceptionTracking needed"
    fi
fi

print_info "Creating TCA feature: $FEATURE_NAME"
print_info "Directory: $FEATURE_DIR"
print_info "Store/View name: $NORMALIZED_NAME"

# Create feature directory
mkdir -p "$FEATURE_DIR"

if [ "$OVERWRITE" = true ]; then
    print_success "Using existing directory"
else
    print_success "Created feature directory"
fi

# Create Store file
STORE_FILE="$FEATURE_DIR/${NORMALIZED_NAME}Store.swift"
cat > "$STORE_FILE" << EOF
import ComposableArchitecture

@Reducer
public struct ${NORMALIZED_NAME}Store: Sendable {
    @ObservableState
    public struct State: Sendable, Equatable {
        public init() { }
    }

    public enum Action: BindableAction, Sendable {
        case binding(BindingAction<State>)
        case onAppear
    }

    public var body: some Reducer<State, Action> {
        BindingReducer()

        Reduce { state, action in
            switch action {
            case .binding:
                return .none

            case .onAppear:
                return handleOnAppear(state: &state)
            }
        }
    }

    public init() { }
}

extension ${NORMALIZED_NAME}Store {
    private func handleOnAppear(state: inout State) -> Effect<Action> {
        return .none
    }
}
EOF

if [ "$OVERWRITE" = true ]; then
    print_success "Overwritten Store file: ${NORMALIZED_NAME}Store.swift"
else
    print_success "Created Store file: ${NORMALIZED_NAME}Store.swift"
fi

# Create View file
VIEW_FILE="$FEATURE_DIR/${NORMALIZED_NAME}View.swift"

if [ "$USE_PERCEPTION_TRACKING" = true ]; then
    # iOS < 17.0 - WITH WithPerceptionTracking
    cat > "$VIEW_FILE" << EOF
import SwiftUI
import ComposableArchitecture

public struct ${NORMALIZED_NAME}View: View {
    public var store: StoreOf<${NORMALIZED_NAME}Store>

    public init(store: StoreOf<${NORMALIZED_NAME}Store>) {
        self.store = store
    }

    public var body: some View {
        WithPerceptionTracking {
            Text("${NORMALIZED_NAME}View")
                .fontDesign(.monospaced)
                .onAppear {
                    store.send(.onAppear)
                }
        }
    }
}
EOF
else
    # iOS 17.0+ - NO WithPerceptionTracking
    cat > "$VIEW_FILE" << EOF
import SwiftUI
import ComposableArchitecture

public struct ${NORMALIZED_NAME}View: View {
    public var store: StoreOf<${NORMALIZED_NAME}Store>

    public init(store: StoreOf<${NORMALIZED_NAME}Store>) {
        self.store = store
    }

    public var body: some View {
        Text("${NORMALIZED_NAME}View")
            .fontDesign(.monospaced)
            .onAppear {
                store.send(.onAppear)
            }
    }
}
EOF
fi

if [ "$OVERWRITE" = true ]; then
    print_success "Overwritten View file: ${NORMALIZED_NAME}View.swift"
else
    print_success "Created View file: ${NORMALIZED_NAME}View.swift"
fi

# Summary
print_info "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
print_success "Feature created successfully!"
print_info "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "ğŸ“ Location: $FEATURE_DIR"
echo ""
echo "Files created:"
echo "  - ${NORMALIZED_NAME}Store.swift"
echo "  - ${NORMALIZED_NAME}View.swift"
echo ""
echo "Structure:"
echo "  State: Empty with public init()"
echo "  Actions: binding, onAppear"
echo "  View: Simple Text with monospaced font"
echo ""
if [ "$USE_PERCEPTION_TRACKING" = true ]; then
    echo "âœ¨ Using WithPerceptionTracking (iOS < 17.0)"
else
    echo "âœ¨ No WithPerceptionTracking needed (iOS 17.0+)"
fi
echo ""

# Auto-update Package.swift
#
# Automatically adds the new feature to Package.swift manifest
# Adds both a product and target entry
#
# Arguments:
#   $1 - Path to Package.swift file
#   $2 - Feature name to add
#
# Returns:
#   0 if successful, 1 if failed
update_package_swift() {
    local package_file="$1"
    local feature_name="$2"

    # Check if feature already exists in Package.swift
    if grep -q "\"$feature_name\"" "$package_file" 2>/dev/null; then
        print_success "Feature '$feature_name' already exists in Package.swift"
        return 0
    fi

    print_info "Updating Package.swift..."

    # Create backup in case update fails
    cp "$package_file" "$package_file.backup"

    # Step 1: Add to products array
    # Uses awk to find the products array and insert before its closing bracket
    awk -v feature="$feature_name" '
    /products: \[/ { in_products=1 }
    in_products && /^    \],/ {
        print "        .singleTargetLibrary(\"" feature "\"),"
        in_products=0
    }
    { print }
    ' "$package_file" > "$package_file.tmp"

    mv "$package_file.tmp" "$package_file"

    # Step 2: Add to targets array (find line with ] before ) at end of targets)
    # Look for the closing ] of the targets array and insert before it
    awk -v feature="$feature_name" '
    /targets: \[/ { in_targets=1 }
    in_targets && /^    \]/ && !done {
        print "        .target("
        print "            name: \"" feature "\","
        print "            dependencies: ["
        print "                .product(name: \"ComposableArchitecture\", package: \"swift-composable-architecture\"),"
        print "            ]"
        print "        ),"
        done=1
    }
    { print }
    ' "$package_file" > "$package_file.tmp"

    mv "$package_file.tmp" "$package_file"

    # Verify the updates were made
    if grep -q "\"$feature_name\"" "$package_file" 2>/dev/null; then
        # Remove backup after successful update
        rm -f "$package_file.backup"
        print_success "Updated Package.swift successfully"
        echo ""
        echo "Added to Package.swift:"
        echo "  âœ“ Product: .singleTargetLibrary(\"$feature_name\")"
        echo "  âœ“ Target: $feature_name with TCA dependency"
        return 0
    else
        # Restore from backup if update failed
        mv "$package_file.backup" "$package_file"
        print_error "Failed to update Package.swift automatically"
        echo ""
        echo "Please manually add to $package_file:"
        echo ""
        echo "1. Add to products array:"
        echo "   .singleTargetLibrary(\"$feature_name\"),"
        echo ""
        echo "2. Add to targets array:"
        echo "   .target("
        echo "       name: \"$feature_name\","
        echo "       dependencies: ["
        echo "           .product(name: \"ComposableArchitecture\", package: \"swift-composable-architecture\"),"
        echo "       ]"
        echo "   ),"
        return 1
    fi
}

# Update Package.swift if found
if [ -n "$PACKAGE_FILE" ]; then
    update_package_swift "$PACKAGE_FILE" "$FEATURE_NAME"
fi
